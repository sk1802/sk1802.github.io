<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Thue–Morse Snowflake</title>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

<style>
  body {
    background: #0b0b0b;
    color: #eee;
    height: 100vh;
    margin: 0;
    overflow: hidden;
  }
  .sidebar {
    width: 300px;
    background: #121212;
    border-right: 1px solid #333;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    background: black;
  }
</style>
</head>

<body>
<div class="d-flex h-100">

  <div class="sidebar p-4">
    <h4 class="text-info mb-4">Thue–Morse Walk</h4>

    <label class="form-label">
      Steps
      <span class="badge bg-primary float-end" id="stepsVal">10000</span>
    </label>
    <input type="range" class="form-range" id="steps"
           min="1000" max="100000" step="100" value="10000">

    <label class="form-label mt-4">
      Angle (deg)
      <span class="badge bg-info float-end" id="angleVal">60</span>
    </label>
    <input type="range" class="form-range" id="angle"
           min="1" max="180" value="60">

    <p class="small text-muted mt-4">
      Parity 0 → move<br>
      Parity 1 → rotate
    </p>
  </div>

  <div class="flex-grow-1">
    <canvas id="canvas"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const stepsEl = document.getElementById("steps");
const angleEl = document.getElementById("angle");
const stepsVal = document.getElementById("stepsVal");
const angleVal = document.getElementById("angleVal");

let redrawReq = null;

// ---- HiDPI-safe resize ----
function resize() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();

  canvas.width  = rect.width * dpr;
  canvas.height = rect.height * dpr;

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpr, dpr);
}

window.addEventListener("resize", () => {
  resize();
  scheduleRedraw();
});

// ---- Thue–Morse parity ----
function parity(n) {
  n ^= n >>> 16;
  n ^= n >>> 8;
  n ^= n >>> 4;
  n ^= n >>> 2;
  n ^= n >>> 1;
  return n & 1;
}

// ---- Debounced redraw ----
function scheduleRedraw() {
  if (redrawReq) cancelAnimationFrame(redrawReq);
  redrawReq = requestAnimationFrame(draw);
}

function draw() {
  const TOTAL = +stepsEl.value;
  const ANGLE = +angleEl.value * Math.PI / 180;

  stepsVal.textContent = TOTAL;
  angleVal.textContent = angleEl.value;

  // clear in CSS pixels
  ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

  let x = 0, y = 0, heading = 0;
  const pts = [{x, y}];

  for (let i = 0; i < TOTAL; i++) {
    if (parity(i)) {
      heading += ANGLE;
    } else {
      x += Math.cos(heading);
      y += Math.sin(heading);
      pts.push({x, y});
    }
  }

  // ---- bounds (logical space) ----
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  for (const p of pts) {
    minX = Math.min(minX, p.x);
    maxX = Math.max(maxX, p.x);
    minY = Math.min(minY, p.y);
    maxY = Math.max(maxY, p.y);
  }

  const w = maxX - minX;
  const h = maxY - minY;

  // IMPORTANT: use CSS size, not canvas.width
  const pad = 40;
  const scale = Math.min(
    (canvas.clientWidth  - pad) / w,
    (canvas.clientHeight - pad) / h
  );

  const ox = canvas.clientWidth  / 2 - (minX + w / 2) * scale;
  const oy = canvas.clientHeight / 2 - (minY + h / 2) * scale;

  ctx.beginPath();
  ctx.moveTo(
    pts[0].x * scale + ox,
    pts[0].y * scale + oy
  );

  for (const p of pts) {
    ctx.lineTo(
      p.x * scale + ox,
      p.y * scale + oy
    );
  }

  ctx.strokeStyle = "#00d4ff";
  ctx.lineWidth = 0.8;
  ctx.lineJoin = ctx.lineCap = "round";
  ctx.stroke();
}

// ---- Auto redraw ----
stepsEl.addEventListener("input", scheduleRedraw);
angleEl.addEventListener("input", scheduleRedraw);

// init
resize();
draw();
</script>
</body>
</html>
